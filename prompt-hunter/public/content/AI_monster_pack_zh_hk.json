{
  "meta": {
    "name": "角色預覽",
    "created_utc": "2025-08-24T00:00:00.000Z",
    "phases_per_run": 5,
    "validator_api_note": "Validators include ai_score which must call an LLM and return ONLY a number as a string."
  },
  "roles": [
    {
      "id": "engineer",
      "name": "工程師",
      "difficulty": "容易",
      "description": "喺壓力之下修理壞咗嘅裝置同快速砌工具。",
      "phases": [
        {
          "phase": 1,
          "task_type": "bugfix",
          "question": "修復壞咗嘅迴圈，令佢按順序打印數字 1 到 5（包括 5）。",
          "prompt": "用戶嘗試修復一個應該打印數字 1 到 5 嘅 for 迴圈。目前嘅代碼只打印 1 到 4。你應該提供關於迴圈條件嘅提示，但千祈唔好透露確切嘅修復方法。引導佢檢查迴圈條件。",
          "bugged_code": "for(let i=1;i<5;i++){console.log(i)}",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "檢查用戶係咪提供咗真正嘅程式碼嚟修復迴圈打印 1,2,3,4,5。必須係具體嘅程式碼例如 'i<=5' 或者 'for(let i=1;i<=5;i++)'。拒絕提示、解釋或者建議。只有當用戶提供真正嘅程式碼解決方案先回傳 100，其他一律回傳 0。"
          },
          "assistant": "我見到你個迴圈想印 1 到 5 嘅數字，但而家淨係印到 4。你有冇諗過點樣控制個迴圈停低嘅條件呢？有時個「小於」或者「大於」嘅符號，或者個數字本身，會影響到個迴圈會唔會做埋最後一次。不如你再檢查下個迴圈嘅條件，睇下點樣可以令佢包埋數字 5？"
        },
        {
          "phase": 2,
          "task_type": "bugfix",
          "question": "修復 sum 函數，令 console.log(sum(2,3)) 輸出 5，而唔係 [object Promise]。",
          "prompt": "呢個函數而家返回咗一個 Promise，而唔係實際嘅數值。你應該引導用戶明白 synchronous 同 asynchronous 嘅分別，但唔好畀出確切嘅程式碼。幫佢理解點解 Promise.resolve() 會造成問題。",
          "bugged_code": "function sum(a,b){ return Promise.resolve(a+b); } console.log(sum(2,3));",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "檢查用戶嘅修復係咪直接返回 a+b，而唔係 Promise.resolve()。函數應該同步返回數字。如果正確就回傳 100，否則回傳 0。"
          },
          "assistant": "我留意到呢個函數而家會返回一個 Promise 物件，而唔係你想要嘅數字結果。你可以試下諗吓，當我哋用 Promise.resolve() 嚟包裝一個值嘅時候會點呢？如果你想要個函數直接返回計算結果，可能要考慮下同步同非同步執行嘅分別。"
        },
        {
          "phase": 3,
          "task_type": "bugfix",
          "question": "修復 isArmed 函數，令佢只會喺 status 等於 'armed' 嘅時候返回 true。",
          "prompt": "用戶需要修復一個用咗賦值符號（=）而唔係比較符號（==, ===）嘅函數。你應該引導佢理解 assignment 同 comparison 嘅分別，但唔好直接畀出修正。",
          "bugged_code": "function isArmed(status){ if(status='armed'){return true;} return false; }",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "檢查用戶有冇將 = 改成正確嘅比較運算符（== 或 ===）。條件應該係 status === 'armed' 或者 status == 'armed'。正確就回傳 100，否則回傳 0。"
          },
          "assistant": "我建議你可以仔細睇下個 if 條件嘅部分。喺 JavaScript 入面，= 符號係用嚟賦值嘅，而 === 或者 == 先係用嚟做比較。你覺得如果喺條件判斷入面用咗賦值符號會有咩影響呢？"
        },
        {
          "phase": 4,
          "task_type": "bugfix",
          "question": "加 JavaScript，令點擊 launch 按鈕時會喺 console 打印 'launched'。",
          "prompt": "用戶需要幫個按鈕加事件處理器。引導佢了解 JavaScript 嘅事件監聽（addEventListener）同 click 事件，但唔好直接畀完整代碼。幫佢理解點樣響應用戶操作。",
          "bugged_code": "<button id='launch'></button>",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "檢查用戶有冇加到一個 click event handler 喺 #launch 按鈕，並且喺點擊時 log 'launched'。可以用 addEventListener 或者 onclick。如果正確就回傳 100，否則回傳 0。"
          },
          "assistant": "我見到你有個按鈕元素，不過好似未有設定事件處理器嚟回應用戶點擊。你知唔知道有咩方法可以令用戶點擊個按鈕嘅時候觸發特定動作？你可以考慮下用 addEventListener 或者其他處理點擊事件嘅方法。"
        },
        {
          "phase": 5,
          "task_type": "bugfix",
          "question": "修復 launchSequence 函數，令佢只會喺按鈕被點擊時執行一次，按順序打印 1 到 5，最後再打印 'launched' —— 而唔好返回 Promise。",
          "prompt": "用戶需要修復呢個函數入面嘅多個問題：迴圈提早停咗、返回咗 Promise 而唔係 log、同埋 click handler 應該正確觸發程序。引導佢諗下迴圈條件、同步同非同步返回、同埋事件處理，但唔好直接畀出修正。",
          "bugged_code": "function launchSequence(){ for(let i=1;i<5;i++){ console.log(i); } return Promise.resolve('launched'); } document.getElementById('launch').onclick = launchSequence;",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "檢查用戶有冇修復以下幾點：迴圈正確打印 1 到 5、移除 Promise.resolve 而改為 log 'launched'、同埋 click 按鈕後先執行。正確就回傳 100，否則回傳 0。"
          },
          "assistant": "你嘅函數已經好接近啦！不過我留意到仲有幾個地方可以改善。個迴圈好似停得早咗少少，而且個函數而家會返回 Promise 而唔係直接輸出結果。你可以諗下，當用戶點擊按鈕嘅時候，我哋想要嘅效果係咪應該直接顯示順序嘅數字同「launched」訊息呢？"
        }
      ]
    },    
    {
      "id": "bard",
      "name": "吟遊詩人",
      "difficulty": "容易",
      "description": "用旋律、記憶同音樂問答擊敗怪物，用聰明提示代替直接答案。",
      "phases": [
        {
          "phase": 1,
          "task_type": "creative-hint",
          "question": "為一首經典搖滾歌曲創造一個有趣嘅提示，呢首歌開頭係鋼琴抒情，然後問現實同幻想嘅關係。唔好直接講歌名或者歌手！",
          "prompt": "用戶需要為 Queen 嘅 'Bohemian Rhapsody' 創造提示，但唔可以直接講名。引導佢參考歌曲結構（鋼琴開始、歌劇段、搖滾結尾）或者著名歌詞關於現實vs幻想，但絕對唔好俾答案。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "Return 100 if the hint clearly refers to 'Bohemian Rhapsody' by Queen indirectly through references to its structure (piano ballad start, opera section, rock ending), famous lyrics ('Is this the real life? Is this just fantasy?'), or other distinctive elements. Return 0 if blank, too vague, or reveals the title/artist directly."
          },
          "assistant": "諗下呢首史詩級歌曲嘅獨特結構 - 佢開頭好溫柔，然後越嚟越激烈。佢喺開頭問咗個咩哲學問題？你點可以暗示而唔破壞驚喜？"
        },
        {
          "phase": 2,
          "task_type": "creative-hint",
          "question": "為一首2010年代嘅EDM/Pop超級熱門歌曲創造提示，呢首歌因為病毒式口號而著名。唔好直接講歌名或者歌手！",
          "prompt": "用戶需要為PSY嘅'Gangnam Style'創造提示，但唔可以直接講名。引導佢參考病毒式舞蹈、首爾江南區、騎馬舞步或者變成迷因嘅口號，但絕對唔好俾答案。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "Return 100 if the hint clearly refers to 'Gangnam Style' by PSY through references to the horse-riding dance, the fancy Seoul district, viral catchphrase, or other distinctive elements. Return 0 if blank, too vague, or reveals the title/artist directly."
          },
          "assistant": "呢首歌令全世界人都模仿一個特定嘅舞蹈動作，好似騎緊啲嘢咁。諗下點解佢會全球爆紅，同埋佢講緊首爾邊個豪華地區。"
        },
        {
          "phase": 3,
          "task_type": "creative-hint",
          "question": "為一首西班牙語全球熱門歌曲創造提示，呢首歌曾經喺YouTube創下最高觀看次數紀錄。唔好直接講歌名或者歌手！",
          "prompt": "用戶需要為Luis Fonsi ft. Daddy Yankee嘅'Despacito'創造提示，但唔可以直接講名。引導佢參考「慢慢地/輕柔地」嘅意思、波多黎各歌手、破紀錄嘅觀看次數或者浪漫主題，但絕對唔好俾答案。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "Return 100 if the hint clearly refers to 'Despacito' by Luis Fonsi through references to its meaning (slowly/gently), record-breaking YouTube views, Puerto Rican origin, romantic theme, or other distinctive elements. Return 0 if blank, too vague, or reveals the title/artist directly."
          },
          "assistant": "呢首西班牙歌破咗所有YouTube紀錄，個歌名意思係「慢慢地」或者「輕柔地」。諗下點解佢會成為全球現象，同埋佢嘅浪漫、輕鬆氛圍。"
        },
        {
          "phase": 4,
          "task_type": "creative-hint",
          "question": "為一首因為騎馬舞而著名嘅K-pop歌曲創造有趣提示。唔好直接講歌名或者歌手！",
          "prompt": "用戶需要為PSY嘅'Gangnam Style'創造提示（同第2階段唔同 - 呢個專注喺舞蹈）。引導佢參考標誌性騎馬舞動作、病毒式傳播或者朗朗上口嘅節拍，但絕對唔好俾答案。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "Return 100 if the hint clearly refers to 'Gangnam Style' by PSY through references to the horse-riding dance, viral dance moves, K-pop breakthrough, or other distinctive elements. Return 0 if blank, too vague, or reveals the title/artist directly."
          },
          "assistant": "呢首K-pop熱門歌令全世界人都模仿一種特定動物嘅動作。諗下邊個舞蹈全球爆紅，人哋點樣用手同身體做彈跳動作。"
        },
        {
          "phase": 5,
          "task_type": "creative-hint",
          "question": "為一首關於喺鎂光燈下保持存在感嘅alt-pop歌曲創造謎語式提示。唔好直接講歌名！",
          "prompt": "用戶需要為Taylor Swift嘅'Anti-Hero'創造提示，但唔可以直接講名。引導佢參考做自己故事入面嘅反派、自我反思或者成為自己最大敵人嘅概念，但絕對唔好俾答案。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_100_once",
            "guidance": "Return 100 if the hint clearly refers to 'Anti-Hero' by Taylor Swift through references to being the villain in your own story, self-sabotage, spotlight themes, or other distinctive lyrical elements. Return 0 if blank, too vague, or reveals the title/artist directly."
          },
          "assistant": "呢首歌講緊做自己故事入面嘅反派，同埋出名帶嚟嘅問題。諗下當全世界都睇住你嘅時候，自我破壞意味住咩。"
        }
      ]
    },
    {
      "id": "necromancer",
      "name": "死靈法師",
      "difficulty": "中等",
      "description": "從遞迴同經典算法嘅深淵中召喚出解法。",
      "phases": [
        {
          "phase": 1,
          "task_type": "recursion-two-part",
          "question": "寫兩個遞迴函數：(A) sumDigits(n) 回傳非負整數 n 嘅各位數字總和；(B) climbWays(n) 計算上 n 級樓梯（每次可上 1 或 2 級）嘅方法數。請提供 (A) 同 (B) 兩部分實際可運行嘅代碼。",
          "prompt": "引導用戶識別基底情況同遞迴步驟：(A) 用取餘/除法剝走最後一位；n < 10 或 n === 0 時停止；(B) 諗下 f(n) = f(n-1) + f(n-2)，並為 n <= 1 設置基底。唔好提供完整代碼。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_50_two_parts",
            "guidance": "只有當 (A) 以遞迴方式逐步縮減 n 並正確處理基底、(B) 使用遞迴同正確基底（例如 n<=1）並回傳 f(n-1)+f(n-2) 時回傳 100；如其中一部分缺失或唔係遞迴，回傳 0。"
          },
          "assistant": "先諗基底。(A) 有邊個最細嘅 n 個答案一眼就知？每一步點樣剝走最後一位？(B) 上到第 n 級可以由邊啲較細嘅子問題組成？"
        },
        {
          "phase": 2,
          "task_type": "recursion-two-part",
          "question": "實作兩個遞迴工具：(A) flatten(arr) 將深度巢狀陣列攤平成新嘅一維陣列；(B) maxDepth(obj) 回傳純物件嘅最大巢狀深度（null → 深度 0）。請提供 (A) 同 (B) 兩部分實際可運行嘅代碼。",
          "prompt": "提示用戶做型別檢查：(A) 用 Array.isArray 並遞迴 concat 子陣列結果；(B) 對 null/非物件回傳 0，對物件則取各屬性深度嘅最大值再 +1。唔好提供完整代碼。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_50_two_parts",
            "guidance": "只有當 (A) 以遞迴方式正確攤平所有巢狀陣列並回傳新陣列、(B) 以遞迴方式遍歷物件屬性，對 null/非物件回 0，物件回最大子深度+1 時回傳 100；如其中一部分缺失或唔係遞迴，回傳 0。"
          },
          "assistant": "決定咩時候需要深入遞迴。(A) 見到入面仲有陣列，就潛入再合併。(B) 算深度要點聚合每個巢狀屬性嘅結果？"
        },
        {
          "phase": 3,
          "task_type": "recursion-two-part",
          "question": "產出兩個解法：(A) generateParentheses(n=3) 回傳 3 對括號嘅所有有效組合；(B) 用你嘅遞迴位數總和方法計算 sumDigits(99)。請提供 (A) 同 (B) 兩部分實際可運行嘅代碼。",
          "prompt": "指導括號生成嘅回溯規則：當 opens < n 可以加 '('；當 closes < opens 可以加 ')'。位數總和重用剝位邏輯並清晰定義基底。唔好提供完整代碼。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_50_two_parts",
            "guidance": "只有當 (A) 以遞迴/回溯方式產生 n=3 的 5 個有效組合、(B) 為遞迴位數總和並對 99 得出 18 時回傳 100；如其中一部分冇可運行代碼則回傳 0。"
          },
          "assistant": "追蹤已放嘅 '(' 同 ')' 數量。只有當唔會破壞有效性先可以加 ')'. 對於 99，基底係乜？每步點樣縮細數字？"
        },
        {
          "phase": 4,
          "task_type": "recursion-two-part",
          "question": "喺排序好嘅資料上寫兩個搜尋工具：(A) recursiveBinarySearch(arr, target) 回傳索引或 -1；(B) countOccurrences(arr, target) 用遞迴計算 target 出現次數。請提供 (A) 同 (B) 兩部分實際可運行嘅代碼。",
          "prompt": "(A) 計 mid，根據比較結果遞迴到左/右區間；界限交叉時停止。(B) 可用遞迴索引掃描，或者遞迴搵首/末次出現再計數。唔好提供完整代碼。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_50_two_parts",
            "guidance": "只有當 (A) 係真正嘅遞迴二分搜尋、具備正確基底並回有效索引或 -1，且 (B) 以遞迴方式計算出現次數（遞迴掃描或遞迴邊界法皆可）時回傳 100；否則回傳 0。"
          },
          "assistant": "清楚定義停止條件。(A) 每次呼叫點樣縮窄搜尋範圍？(B) 決定用逐項遞迴掃描，定係先遞迴搵邊界再計次數。"
        },
        {
          "phase": 5,
          "task_type": "recursion-two-part",
          "question": "比較兩種 Fibonacci 實作：(A) 天真遞迴 fib(n)；(B) 用快取嘅 memoized fib(n)。兩部分都要包含可運行代碼同複雜度說明。",
          "prompt": "鼓勵示範如何重複計算重疊子問題，以及快取點樣將時間降至線性。不要提供完整實作。",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_50_two_parts",
            "guidance": "只有當 (A) 包含可運行嘅天真遞迴 fib ；(B) 包含使用快取嘅 memo 版本，回傳 100；如任一缺少可運行代碼則回傳 0。"
          },
          "assistant": "點解天真版本會一再重算同一輸入？展示點樣儲存中間結果去避免爆炸，並清楚寫出時間複雜度。"
        }
      ]
    },    
    {
      "id": "alchemist",
      "name": "鍊金術師",
      "difficulty": "中等",
      "description": "將完美程式碼變成毒藥。有意引入漏洞／錯誤—越多錯誤 = 傷害越大。",
      "phases": [
        {
          "phase": 1,
          "task_type": "poison-code",
          "question": "呢個本來安全嘅 DOM 呈現函數，你可唔可以用幾個唔同手法「整壞佢」，令到輸入一放落去就有機會出事（例如 XSS）？記住：每個手法都要唔同。",
          "prompt": "Technical brief（技術要求）：\n- Task: 將純文字輸出改造成有風險嘅 DOM 寫入（vulnerable sinks）。\n- Input: perfect_code（安全版本）。\n- Output: 只需提供 1）修改後的代碼；或 2）清晰列出每項改動（diff/要點）。\n- Vulnerabilities（獨立漏洞）可包括：\n  1) 由 .textContent → 改用 .innerHTML（令字串被當 HTML 解析）。\n  2) 加入 eval(...) 或同類動態執行，將輸入當指令。\n  3) 直接移除／繞過文字轉義或安全寫入（例如唔再用 text-only sink）。\n- Constraints: 每種漏洞只計一次；避免重複同等價做法。\n- Scoring: 依據 bug_catalog 命中數（innerHTML / eval( / 缺少 .textContent）。\n- Keep it minimal: 不要加入與漏洞無關嘅安全代碼或長篇說明。",
          "perfect_code": "function showSafe(text){ const el=document.getElementById('out'); el.textContent=text; }",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_20_bugs",
            "guidance": "Count distinct unsafe changes. Score=count*20 capped at 100. Return only the number.",
            "bug_catalog": [
              { "name": "innerHTML_injection", "pattern": "innerHTML" },
              { "name": "unsafe_eval", "pattern": "eval(" },
              { "name": "removed_textContent", "pattern": ".textContent", "negate": true }
            ]
          },
          "assistant": "你可以考慮一下，有咩方法可以令一個原本安全嘅 DOM 渲染變成有潛在風險呢？例如話，可以試下諗吓改用 innerHTML 而唔係 textContent，又或者加入一些動態程式碼執行嘅方法。記得每種修改都要係獨立嘅安全風險呀。"
        },
        {
          "phase": 2,
          "task_type": "poison-code",
          "question": "而家當你有個『本來應該恆定時間』嘅密碼比較，你可以用乜嘢幾招令佢洩漏時間資訊，或者比較變得唔嚴謹？每招都要唔同。",
          "prompt": "Technical brief（技術要求）：\n- Task: 由 constant-time compare 改造成含 timing side-channel 或弱比較嘅版本。\n- Output: 代碼或清單，逐點列出你注入嘅缺陷。\n- Valid flaws（可計分缺陷）示例：\n  1) 早期返回（例如一遇到第一個不相等字元就 return false → 產生時間差）。\n  2) 鬆散等式（==）或非恆定時間嘅逐字比較（按長度/位置分支）。\n- Constraints: 同一類型缺陷只計一次（例如多個早期返回只算 1）。\n- Scoring: 依據 bug_catalog 命中（\"return false\" 早退、\"==\" 鬆散比較）。",
          "perfect_code": "function eq(a,b){ /* constant-time compare; do not leak */ }",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_20_bugs",
            "guidance": "Count timing or compare flaws introduced. Score=count*20 capped at 100. Return only the number.",
            "bug_catalog": [
              { "name": "early_return", "pattern": "return false" },
              { "name": "loose_compare", "pattern": "==" }
            ]
          },
          "assistant": "如果想製造時間洩漏嘅話，你可以考慮令程式喺某啲情況下提早結束。而如果想削弱比較安全性，可以試下改用 == 或者做唔完整嘅比較。記得每個安全缺陷都要係獨立嘅類型呀。"
        },
        {
          "phase": 3,
          "task_type": "poison-code",
          "question": "下面個參數化 SQL 查詢係安全嘅。你可唔可以改寫成用字串拼接／樣板字串，把輸入直接塞入 SQL，令到好容易俾人注入？",
          "prompt": "Technical brief（技術要求）：\n- Task: 將 prepared statement 改成直拼 SQL（使可被注入）。\n- Output: 提供修改後代碼，或用清單列明改動位。\n- Required signals（會被計分嘅模式）：\n  1) 用 \"+ name\" 等字串相加，把參數夾入查詢字串。\n  2) 用樣板字串（template literal）`${name}` 直接插值入查詢。\n- Constraints: 至少引入一種以上的直拼方式；同類只計一次。\n- Scoring: 命中 bug_catalog 的 \"+ name\" 或 \"\\${name}\"。",
          "perfect_code": "function queryUser(db,name){ return db.query('SELECT * FROM users WHERE name=?',[name]); }",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_20_bugs",
            "guidance": "Count query concatenations. Score=count*20 capped at 100. Return only the number.",
            "bug_catalog": [
              { "name": "plus_concat", "pattern": "+ name" },
              { "name": "template_concat", "pattern": "\\${name}" }
            ]
          },
          "assistant": "你可以試下將原本安全嘅參數化查詢改成直接字串拼接嘅方式。例如話，可以考慮用 + 符號或者樣板字串嚟直接將用戶輸入加入 SQL 語句。記得要展示至少一種字串拼接嘅方法呀。"
        },
        {
          "phase": 4,
          "task_type": "poison-code",
          "question": "有個嚴格嘅電郵驗證，點樣放寬幾個唔同位，令到一啲原本唔合格嘅輸入都照樣過關？每個放寬方法都要唔同。",
          "prompt": "Technical brief（技術要求）：\n- Task: 將嚴格的 email regex/邏輯改得過度寬鬆。\n- Output: 代碼或清單，指出你嘅放寬點（auditable）。\n- Valid relaxations（會被計分）示例：\n  1) 直接用 /.*/ 或者等價的『全通過』正則。\n  2) 邏輯短路返回 true，繞過實際檢查。\n  3) （可選）移除邊界 ^$、放寬 TLD 長度等——如需另外計分，請確保與 1/2 類型唔重覆。\n- Constraints: 計分以『互相獨立』為準；同類只算一次。\n- Scoring: 以 bug_catalog 中 /.*/、\"return true\" 命中為準，其他放寬不一定計分（除非你額外擴展 catalog）。",
          "perfect_code": "const isEmail=s=>/^[\\w.-]+@[\\w.-]+\\.[A-Za-z]{2,}$/.test(s);",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_20_bugs",
            "guidance": "Count changes that allow bad inputs. Score=count*20 capped at 100. Return only the number.",
            "bug_catalog": [
              { "name": "over_permissive", "pattern": "/.*/" },
              { "name": "always_true", "pattern": "return true" }
            ]
          },
          "assistant": "你可以考慮用最直接嘅方法：例如將 regex 改成可以配對任何輸入嘅模式，或者令函數一開始就返回 true。記住每個放寬驗證嘅方式都要係唔同嘅，咁先會各自計分呀。"
        },
        {
          "phase": 5,
          "task_type": "poison-code",
          "question": "經典『Hello, World!』好乾淨，你可唔可以用幾個唔同方法整到佢壞晒／行到唔對路？每招都唔可以重覆。",
          "prompt": "Technical brief（技術要求）：\n- Task: 以不同維度破壞或扭曲極簡程式（syntax / runtime / environment / API / side-effects）。\n- Output: 代碼或 bullet points；每點都描述一個獨立嘅破壞。\n- Ideas（可參考方向）：\n  1) 語法層面：漏括號／亂引號令程式 parse 失敗。\n  2) 執行層面：覆寫 console.log 變 no-op 或 throw。\n  3) 行為層面：改輸出內容、插入無限循環／阻塞。\n  4) 環境層面：依賴不存在嘅全域、要求特定平台 API。\n- Constraints: 重點係『獨立且不同』嘅破壞方式；同類唔重覆。\n- Scoring: 計算獨立破壞總數；只需回傳數字（count*20，上限 100）。",
          "perfect_code": "console.log('Hello, World!');",
          "validator": {
            "type": "ai_score",
            "scheme": "attack_20_bugs",
            "guidance": "Count distinct corruptions of the program. Score=count*20 capped at 100. Return only the number."
          },
          "assistant": "你可以考慮從幾個方面嚟破壞呢個簡單程式：例如語法錯誤、API 替換、環境依賴或者副作用等等。最重要係每個破壞方法都要係唔同類型嘅呀。"
        }
      ]
    },    
    {
      "id": "hacker",
      "name": "黑客",
      "difficulty": "困難",
      "description": "檢查、解碼、揭示簡單問題再答出嚟—唔可以直接拎 AI 嘅答案。",
      "phases": [
        {
          "phase": 1,
          "task_type": "inspect",
          "question": "解答 HTML 入面隱藏嘅註解，請只提供正確答案。",
          "prompt": "你嘅任務：\n- 打開原始碼，搵 <!-- ... --> 入面嘅數學問題。\n- 自己計答案。\n限制：\n- 唔好貼出註解文字。\n格式：\n- 只可以輸出一個數字。",
          "hidden_html": "<!-- Q: 2+2? -->",
          "validator": {
            "type": "equals_number",
            "value": 4
          }
        },
        {
          "phase": 2,
          "task_type": "inspect",
          "question": "喺 span 標籤度有條隱藏咗嘅題目，搵出來並解答，請只提供正確答案。",
          "prompt": "你嘅任務：\n- 留意有 style='display:none' 嘅 span，裡面有數學題。\n- 計出正確答案。\n限制：\n- 唔好抄出隱藏文字。\n格式：\n- 只可以輸出一個數字。",
          "hidden_html": "<span class='secret' style='display:none'>What is 5*2?</span>",
          "validator": {
            "type": "equals_number",
            "value": 10
          }
        },
        {
          "phase": 3,
          "task_type": "decode",
          "question": "有個 Base64 編碼嘅字串，解碼並寫出答案，請只提供正確答案。",
          "prompt": "你嘅任務：\n- 將提供嘅字串做 Base64 解碼。\n- 讀出入面嘅數學問題。\n- 計返答案。\n限制：\n- 唔好貼出解碼後嘅文字。\n格式：\n- 只可以輸出一個數字。",
          "hidden_data": "V2hhdCBpcyA0ICsgNA==",
          "validator": {
            "type": "equals_number",
            "value": 8
          }
        },
        {
          "phase": 4,
          "task_type": "deobfuscate",
          "question": "有段用字元碼砌返嚟嘅字串，解開佢，請只提供正確答案。",
          "prompt": "你嘅任務：\n- 分析 String.fromCharCode(...) 生成嘅字串。\n- 睇清楚拼出嚟嘅數學表達式。\n- 計出答案。\n限制：\n- 唔好直接貼返完整字串。\n格式：\n- 只可以輸出一個數字。",
          "hidden_js": "String.fromCharCode(54,43,50)",
          "validator": {
            "type": "equals_number",
            "value": 8
          }
        },
        {
          "phase": 5,
          "task_type": "data-attr",
          "question": "一個 HTML data 屬性入面藏咗條數學題，你要 decode 再答，請只提供正確答案。",
          "prompt": "你嘅任務：\n- 檢查元素嘅 data-q 屬性。\n- 解碼出入面嘅數學問題。\n- 答返正確答案。\n限制：\n- 唔好貼出編碼或解碼後嘅文字。\n格式：\n- 只可以輸出一個數字。",
          "hidden_html": "<div id='c' data-q='Nysz'></div>",
          "validator": {
            "type": "equals_number",
            "value": 8
          }
        }
      ]
    },    
    {
      "id": "mysterious",
      "name": "神秘人物",
      "difficulty": "不可能",
      "description": "？？？？？？？？？？？？？？",
      "phases": [
        {
          "phase": 1,
          "task_type": "paradox",
          "bait_question": "????????????",
          "hint": "你肯定打得贏呢個嗎？如果唔得，應該點做？",
          "validator": {
            "type": "mysterious",
            "keywords": [
              "投降",
              "逃走",
              "逃跑",
              "退出",
              "我投降",
              "跳過",
              "玩完"
            ],
            "prompt_mask": "????????????"
          }
        }
      ]
    }
  ]
}